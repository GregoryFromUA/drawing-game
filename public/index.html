<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doodle Prophet Unicorn Canvas Cobra</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .lobby {
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 700px;
            margin: 50px auto;
        }
        
        .lobby h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2.2em;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .room-code {
            background: #f0f0f0;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 20px 0;
        }
        
        .room-code h2 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .room-code .code {
            font-size: 2em;
            font-weight: bold;
            letter-spacing: 5px;
            color: #333;
        }
        
        .rules-section {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            border: 2px solid #ff9800;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .rules-section h3 {
            color: #e65100;
            margin-bottom: 15px;
            font-size: 1.3em;
            text-align: center;
        }
        
        .rules-section ul {
            list-style: none;
            padding: 0;
        }
        
        .rules-section li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
            line-height: 1.5;
        }
        
        .rules-section li::before {
            content: "⚠️";
            position: absolute;
            left: 0;
        }
        
        .players-list {
            margin: 20px 0;
        }
        
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f8f8;
            margin: 10px 0;
            border-radius: 10px;
            transition: all 0.3s;
        }
        
        .player-item.ready {
            background: #d4f4dd;
            border: 2px solid #4caf50;
        }
        
        .player-item.disconnected {
            opacity: 0.5;
            background: #ffebee;
        }
        
        .player-name {
            font-weight: 600;
            font-size: 1.1em;
        }
        
        .player-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            background: white;
        }
        
        .ready-badge {
            background: #4caf50;
            color: white;
        }
        
        .input-group {
            margin: 20px 0;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #555;
        }
        
        .input-group input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1.1em;
            transition: border-color 0.3s;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            width: 100%;
            margin: 10px 0;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .btn-success {
            background: #4caf50;
            color: white;
        }
        
        .btn-success:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(76, 175, 80, 0.4);
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            min-height: calc(100vh - 40px);
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f8f8;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .round-info {
            font-size: 1.2em;
            font-weight: 600;
            color: #667eea;
        }
        
        .word-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: #f8f8f8;
            border-radius: 15px;
        }
        
        .word-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .word-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }
        
        .word-list {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .word-item {
            padding: 8px;
            background: #f0f0f0;
            border-radius: 5px;
            text-align: center;
            font-size: 0.95em;
            position: relative;
        }
        
        .word-item.my-word {
            background: #ffd700;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .word-number {
            position: absolute;
            top: -5px;
            left: -5px;
            background: #667eea;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .personal-task {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.3);
        }
        
        .personal-task h3 {
            color: #333;
            margin-bottom: 10px;
        }
        
        .personal-task .task-word {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin: 10px 0;
        }
        
        .personal-task .task-info {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }
        
        .task-badge {
            padding: 5px 15px;
            background: white;
            border-radius: 20px;
            font-weight: 600;
        }
        
        .drawing-section {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
            align-items: flex-start;
        }
        
        .tools-panel {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 15px;
            height: fit-content;
            width: 220px;
            flex-shrink: 0;
        }
        
        .tools-panel h3 {
            margin-bottom: 15px;
            color: #667eea;
        }
        
        .tool-group {
            margin: 15px 0;
        }
        
        .tool-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }
        
        .color-palette {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .color-btn {
            width: 35px;
            height: 35px;
            border: 3px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .color-btn:hover {
            transform: scale(1.1);
        }
        
        .color-btn.active {
            border-color: #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
        }
        
        .size-selector {
            display: flex;
            gap: 8px;
        }
        
        .size-btn {
            width: 35px;
            height: 35px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }
        
        .size-btn:hover {
            border-color: #667eea;
        }
        
        .size-btn.active {
            background: #667eea;
            border-color: #667eea;
        }
        
        .size-dot {
            border-radius: 50%;
            background: #333;
        }
        
        .size-btn.active .size-dot {
            background: white;
        }
        
        .canvas-container {
            background: white;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            padding: 10px;
            position: relative;
            max-width: 660px;
            margin: 0 auto;
        }
        
        .canvas-container.locked {
            border-color: #f44336;
            background: #ffebee;
        }
        
        .canvas-lock-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(244, 67, 54, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            z-index: 10;
        }
        
        .lock-message {
            background: #f44336;
            color: white;
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: 600;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
            background: white;
            border-radius: 10px;
            image-rendering: auto;
            max-width: 100%;
            height: auto;
        }
        
        .other-drawings {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 15px;
            margin: 20px 0;
            justify-items: center;
        }
        
        .drawing-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            padding: 10px;
            position: relative;
            width: 260px;
        }
        
        .drawing-card.guessed {
            border-color: #4caf50;
            background: #f1f8e9;
        }
        
        .drawing-player-name {
            text-align: center;
            font-weight: 600;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 0.95em;
        }
        
        .guess-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin-top: 8px;
        }
        
        .guess-btn {
            padding: 6px;
            border: 2px solid #e0e0e0;
            background: white;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }
        
        .guess-btn:hover:not(:disabled) {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }
        
        .guess-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .guess-btn.selected {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }
        
        .guess-btn.used {
            background: #f44336;
            color: white;
            border-color: #f44336;
            text-decoration: line-through;
        }
        
        .score-hint {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border: 2px solid #2196f3;
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.2);
        }
        
        .score-hint h4 {
            color: #1565c0;
            margin-bottom: 15px;
            font-size: 1.2em;
            text-align: center;
        }
        
        .score-hint-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .score-hint-item {
            background: white;
            padding: 10px;
            border-radius: 10px;
        }
        
        .score-hint-item h5 {
            color: #1976d2;
            margin-bottom: 8px;
            font-size: 1em;
        }
        
        .score-hint-item p {
            font-size: 0.9em;
            line-height: 1.4;
            color: #555;
        }
        
        .results-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .results-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .results-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .results-header h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .scores-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .scores-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .scores-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .scores-table tr:hover {
            background: #f8f8f8;
        }
        
        .score-change {
            color: #4caf50;
            font-weight: 600;
        }
        
        .winner-announcement {
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin: 20px 0;
        }
        
        .winner-announcement h3 {
            font-size: 2.5em;
            color: #333;
            margin-bottom: 10px;
        }
        
        .winner-name {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
        }
        
        .final-score {
            font-size: 1.5em;
            color: #555;
            margin-top: 10px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .lobby {
                padding: 20px;
                margin: 20px auto;
            }
            
            .word-grid {
                grid-template-columns: 1fr;
            }
            
            .word-list {
                grid-template-columns: repeat(3, 1fr);
                font-size: 0.85em;
            }
            
            .drawing-section {
                flex-direction: column;
                align-items: center;
            }
            
            .canvas-container {
                max-width: 100%;
            }
            
            .tools-panel {
                display: flex;
                flex-wrap: wrap;
                gap: 15px;
                justify-content: space-around;
            }
            
            .other-drawings {
                grid-template-columns: 1fr;
            }
            
            .score-hint-content {
                grid-template-columns: 1fr;
            }
        }
        
        .loading {
            text-align: center;
            padding: 40px;
        }
        
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .error-message {
            background: #ffebee;
            color: #c62828;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Конфігурація
       const SERVER_URL = window.location.hostname === 'localhost' 
  ? 'http://localhost:3001' 
  : 'https://doodle-prophet-unicorn-canvas-cobra.onrender.com/';

        
        // Головний компонент гри
        function Game() {
            const [socket, setSocket] = useState(null);
            const [gameState, setGameState] = useState('menu');
            const [roomCode, setRoomCode] = useState('');
            const [playerId, setPlayerId] = useState('');
            const [playerName, setPlayerName] = useState('');
            const [roomData, setRoomData] = useState(null);
            const [roundData, setRoundData] = useState(null);
            const [drawings, setDrawings] = useState({});
            const [myGuesses, setMyGuesses] = useState({});
            const [usedNumbers, setUsedNumbers] = useState(new Set());
            const [isDrawingLocked, setIsDrawingLocked] = useState(false);
            const [roundResults, setRoundResults] = useState(null);
            const [finalResults, setFinalResults] = useState(null);
            const [error, setError] = useState('');
            const [isHost, setIsHost] = useState(false);
            const [finishedDrawingPlayers, setFinishedDrawingPlayers] = useState(new Set());
            
            // Ініціалізація Socket.io
            useEffect(() => {
                const newSocket = io(SERVER_URL);
                
                newSocket.on('connect', () => {
                    console.log('Connected to server');
                });
                
                newSocket.on('room_created', ({ roomCode, playerId, state }) => {
                    setRoomCode(roomCode);
                    setPlayerId(playerId);
                    setRoomData(state);
                    setGameState('lobby');
                    setIsHost(true);
                    localStorage.setItem('gameSession', JSON.stringify({ roomCode, playerId, playerName }));
                });
                
                newSocket.on('joined_room', ({ roomCode, playerId, state }) => {
                    setRoomCode(roomCode);
                    setPlayerId(playerId);
                    setRoomData(state);
                    setGameState('lobby');
                    setIsHost(state.hostId === playerId);
                    localStorage.setItem('gameSession', JSON.stringify({ roomCode, playerId, playerName }));
                });
                
                newSocket.on('player_joined', (state) => {
                    setRoomData(state);
                });
                
                newSocket.on('player_ready_changed', (state) => {
                    setRoomData(state);
                });
                
                newSocket.on('round_started', (data) => {
                    setRoundData(data);
                    setGameState('playing');
                    setDrawings({});
                    setMyGuesses({});
                    setUsedNumbers(new Set());
                    setIsDrawingLocked(false);
                    setFinishedDrawingPlayers(new Set());
                });
                
                newSocket.on('drawing_updated', ({ playerId, strokes }) => {
                    setDrawings(prev => ({
                        ...prev,
                        [playerId]: [...(prev[playerId] || []), ...strokes]
                    }));
                });
                
                newSocket.on('canvas_cleared', ({ playerId }) => {
                    setDrawings(prev => ({
                        ...prev,
                        [playerId]: []
                    }));
                });
                
                newSocket.on('drawing_locked', ({ playerId: lockedPlayerId }) => {
                    if (lockedPlayerId === playerId) {
                        setIsDrawingLocked(true);
                    }
                });
                
                newSocket.on('player_finished_drawing', ({ playerId: finishedPlayerId }) => {
                    setFinishedDrawingPlayers(prev => new Set([...prev, finishedPlayerId]));
                });
                
                newSocket.on('guess_accepted', ({ targetId, number }) => {
                    setMyGuesses(prev => ({ ...prev, [targetId]: number }));
                    setUsedNumbers(prev => new Set([...prev, number]));
                });
                
                newSocket.on('round_ended', (results) => {
                    setRoundResults(results);
                    setGameState('round_end');
                });
                
                newSocket.on('game_ended', (results) => {
                    setFinalResults(results);
                    setGameState('game_end');
                });
                
                newSocket.on('game_reset', (state) => {
                    setRoomData(state);
                    setGameState('lobby');
                    setRoundData(null);
                    setRoundResults(null);
                    setFinalResults(null);
                });
                
                newSocket.on('error', ({ message }) => {
                    setError(message);
                });
                
                newSocket.on('player_disconnected', ({ playerId: disconnectedId, state }) => {
                    setRoomData(state);
                });
                
                setSocket(newSocket);
                
                // Спроба відновити сесію
                const savedSession = localStorage.getItem('gameSession');
                if (savedSession) {
                    const { roomCode: savedRoom, playerId: savedId, playerName: savedName } = JSON.parse(savedSession);
                    if (savedRoom && savedId && savedName) {
                        setPlayerName(savedName);
                        newSocket.emit('join_room', { 
                            roomCode: savedRoom, 
                            playerName: savedName, 
                            playerId: savedId 
                        });
                    }
                }
                
                return () => {
                    newSocket.close();
                };
            }, []);
            
            // Обробники подій
            const createRoom = () => {
                if (playerName.trim() && socket) {
                    socket.emit('create_room', { playerName });
                }
            };
            
            const joinRoom = () => {
                if (playerName.trim() && roomCode.trim() && socket) {
                    socket.emit('join_room', { roomCode: roomCode.toUpperCase(), playerName });
                }
            };
            
            const toggleReady = () => {
                if (socket && roomData) {
                    const isReady = roomData.players.find(p => p.id === playerId)?.ready;
                    socket.emit('player_ready', { ready: !isReady });
                }
            };
            
            const startGame = () => {
                if (socket && isHost) {
                    socket.emit('start_game');
                }
            };
            
            const finishDrawing = () => {
                if (socket) {
                    socket.emit('finish_drawing');
                    setIsDrawingLocked(true);
                }
            };
            
            const makeGuess = (targetId, number) => {
                if (socket && !myGuesses[targetId] && !usedNumbers.has(number)) {
                    socket.emit('make_guess', { targetId, number });
                }
            };
            
            const finishGuessing = () => {
                if (socket) {
                    socket.emit('finish_guessing');
                }
            };
            
            const nextRound = () => {
                if (socket && isHost) {
                    socket.emit('next_round');
                }
            };
            
            const newGame = () => {
                if (socket && isHost) {
                    socket.emit('new_game');
                }
            };
            
            // Рендер різних екранів
            if (gameState === 'menu') {
                const hasRoomCode = roomCode.trim().length > 0;
                const hasPlayerName = playerName.trim().length > 0;
                const canJoin = hasRoomCode && hasPlayerName;
                
                return (
                    <div className="container">
                        <div className="lobby">
                            <h1>Doodle Prophet Unicorn Canvas Cobra</h1>
                            
                            {error && <div className="error-message">{error}</div>}
                            
                            <div className="input-group">
                                <label>Ваше ім'я:</label>
                                <input
                                    type="text"
                                    value={playerName}
                                    onChange={(e) => setPlayerName(e.target.value)}
                                    placeholder={hasRoomCode && !hasPlayerName ? "Введіть своє ім'я ТУТ" : "Captain Obvious"}
                                    maxLength={20}
                                    style={hasRoomCode && !hasPlayerName ? {borderColor: '#ff9800', borderWidth: '2px'} : {}}
                                />
                            </div>
                            
                            <button 
                                className="btn btn-primary"
                                onClick={createRoom}
                                disabled={!playerName.trim()}
                            >
                                Створити кімнату
                            </button>
                            
                            <div style={{ margin: '20px 0', textAlign: 'center' }}>
                                <span style={{ color: '#999' }}>— або —</span>
                            </div>
                            
                            <div className="input-group">
                                <label>Код кімнати:</label>
                                <input
                                    type="text"
                                    value={roomCode}
                                    onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
                                    placeholder="Введіть код кімнати"
                                    maxLength={6}
                                />
                            </div>
                            
                            <button 
                                className={`btn ${canJoin ? 'btn-success' : 'btn-secondary'}`}
                                onClick={joinRoom}
                                disabled={!canJoin}
                            >
                                Приєднатися до кімнати
                            </button>
                        </div>
                    </div>
                );
            }
            
            if (gameState === 'lobby') {
                return (
                    <div className="container">
                        <div className="lobby">
                            <h1>Кімната очікування</h1>
                            
                            <div className="room-code">
                                <h2>Код кімнати:</h2>
                                <div className="code">{roomCode}</div>
                            </div>
                            
                            <div className="rules-section">
                                <h3>ПРАВИЛА МАЛЮВАННЯ</h3>
                                <ul>
                                    <li>1. НЕ МОЖНА - Малювати літери. Наприклад, якщо вам випало слово "КНИГА", ви не можете намалювати літери К-Н-И-Г-А.</li>
                                    <li>2. НЕ МОЖНА - Використовувати цифри чи символи, які прямо вказують на слово. Наприклад, для слова "сім'я" не можна намалювати цифру 7 і літеру Я.</li>
                                    <li>3. Заборонено за допомогою малюнка натякати на літеру чи цифру вашого завдання</li>
									<li>Вам потрібно передати ідею, суть, концепцію слова через візуальні образи чи асоціації.</li>
                                </ul>
                            </div>
                            
                            <div className="players-list">
                                <h3>Гравці ({roomData?.players?.length || 0}/9):</h3>
                                {roomData?.players?.map(player => (
                                    <div 
                                        key={player.id}
                                        className={`player-item ${player.ready ? 'ready' : ''} ${!player.connected ? 'disconnected' : ''}`}
                                    >
                                        <span className="player-name">
                                            {player.name}
                                            {player.id === playerId && ' (Ви)'}
                                            {player.id === roomData.hostId && ' 👑'}
                                        </span>
                                        <span className={`player-status ${player.ready ? 'ready-badge' : ''}`}>
                                            {!player.connected ? 'Відключений' : player.ready ? 'Готовий' : 'Не готовий'}
                                        </span>
                                    </div>
                                ))}
                            </div>
                            
                            <button 
                                className={`btn ${roomData?.players?.find(p => p.id === playerId)?.ready ? 'btn-danger' : 'btn-success'}`}
                                onClick={toggleReady}
                            >
                                {roomData?.players?.find(p => p.id === playerId)?.ready ? 'Не готовий' : 'Готовий'}
                            </button>
                            
                            {isHost && (
                                <button 
                                    className="btn btn-primary"
                                    onClick={startGame}
                                    disabled={roomData?.players?.length < 3 || !roomData?.players?.every(p => p.ready)}
                                >
                                    Почати гру
                                    {roomData?.players?.length < 3 && ' (мінімум 3 гравці)'}
                                </button>
                            )}
                        </div>
                    </div>
                );
            }
            
            if (gameState === 'playing') {
                return (
                    <GameBoard
                        socket={socket}
                        playerId={playerId}
                        roundData={roundData}
                        drawings={drawings}
                        setDrawings={setDrawings}
                        myGuesses={myGuesses}
                        usedNumbers={usedNumbers}
                        isDrawingLocked={isDrawingLocked}
                        finishDrawing={finishDrawing}
                        makeGuess={makeGuess}
                        finishGuessing={finishGuessing}
                        finishedDrawingPlayers={finishedDrawingPlayers}
                    />
                );
            }
            
            if (gameState === 'round_end') {
                return (
                    <div className="results-modal">
                        <div className="results-content">
                            <div className="results-header">
                                <h2>Результати раунду {roundData?.round}</h2>
                            </div>
                            
                            <div className="scores-table">
                                <table style={{ width: '100%' }}>
                                    <thead>
                                        <tr>
                                            <th>Гравець</th>
                                            <th>Очки за раунд</th>
                                            <th>Загальні очки</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {Object.entries(roundResults?.totalScores || {})
                                            .sort(([,a], [,b]) => b - a)
                                            .map(([pid, score]) => {
                                                const player = roundData?.players?.find(p => p.id === pid);
                                                return (
                                                    <tr key={pid}>
                                                        <td>
                                                            {player?.name}
                                                            {pid === playerId && ' (Ви)'}
                                                        </td>
                                                        <td className="score-change">
                                                            +{roundResults?.roundScores[pid] || 0}
                                                        </td>
                                                        <td style={{ fontWeight: 'bold' }}>
                                                            {score}
                                                        </td>
                                                    </tr>
                                                );
                                            })}
                                    </tbody>
                                </table>
                            </div>
                            
                            {isHost && roundData?.round < 4 && (
                                <button className="btn btn-primary" onClick={nextRound}>
                                    Наступний раунд
                                </button>
                            )}
                        </div>
                    </div>
                );
            }
            
            if (gameState === 'game_end') {
                const sortedScores = Object.entries(finalResults?.finalScores || {})
                    .sort(([,a], [,b]) => b - a);
                const winner = roundData?.players?.find(p => p.id === sortedScores[0]?.[0]);
                
                return (
                    <div className="results-modal">
                        <div className="results-content">
                            <div className="winner-announcement">
                                <h3>🏆 Переможець!</h3>
                                <div className="winner-name">{winner?.name}</div>
                                <div className="final-score">{sortedScores[0]?.[1]} очок</div>
                            </div>
                            
                            <div className="scores-table">
                                <table style={{ width: '100%' }}>
                                    <thead>
                                        <tr>
                                            <th>Місце</th>
                                            <th>Гравець</th>
                                            <th>Очки</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {sortedScores.map(([pid, score], index) => {
                                            const player = roundData?.players?.find(p => p.id === pid);
                                            return (
                                                <tr key={pid}>
                                                    <td style={{ fontSize: '1.5em' }}>
                                                        {index === 0 && '🥇'}
                                                        {index === 1 && '🥈'}
                                                        {index === 2 && '🥉'}
                                                        {index > 2 && (index + 1)}
                                                    </td>
                                                    <td>
                                                        {player?.name}
                                                        {pid === playerId && ' (Ви)'}
                                                    </td>
                                                    <td style={{ fontWeight: 'bold', fontSize: '1.2em' }}>
                                                        {score}
                                                    </td>
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                            
                            {isHost && (
                                <button className="btn btn-primary" onClick={newGame}>
                                    Нова гра
                                </button>
                            )}
                        </div>
                    </div>
                );
            }
            
            return <div className="loading"><div className="loading-spinner"></div></div>;
        }
        
        // Компонент ігрової дошки
        function GameBoard({ 
            socket, 
            playerId, 
            roundData, 
            drawings, 
            setDrawings,
            myGuesses, 
            usedNumbers, 
            isDrawingLocked,
            finishDrawing,
            makeGuess,
            finishGuessing,
            finishedDrawingPlayers
        }) {
            const canvasRef = useRef(null);
            const [isDrawing, setIsDrawing] = useState(false);
            const [currentColor, setCurrentColor] = useState('#000000');
            const [currentSize, setCurrentSize] = useState(5);
            const [currentTool, setCurrentTool] = useState('pen');
            const [hasFinishedDrawing, setHasFinishedDrawing] = useState(false);
            const [hasFinishedGuessing, setHasFinishedGuessing] = useState(false);
            const [myDrawingData, setMyDrawingData] = useState([]);
            const strokeBufferRef = useRef([]);
            const lastXRef = useRef(null);
            const lastYRef = useRef(null);
            
            const colors = [
                '#000000', '#FF0000', '#00FF00', '#0000FF', 
                '#FFFF00', '#FF00FF', '#00FFFF', '#FFA500', 
                '#800080', '#A52A2A', '#FFC0CB', '#808080'
            ];
            
            const sizes = [2, 4, 7, 11, 16];
            
            // Оптимізована синхронізація малювання
            useEffect(() => {
                let animationFrameId;
                
                const sendStrokes = () => {
                    if (strokeBufferRef.current.length > 0 && socket) {
                        socket.emit('drawing_update', { 
                            strokes: strokeBufferRef.current 
                        });
                        strokeBufferRef.current = [];
                    }
                    animationFrameId = requestAnimationFrame(sendStrokes);
                };
                
                animationFrameId = requestAnimationFrame(sendStrokes);
                
                return () => {
                    cancelAnimationFrame(animationFrameId);
                };
            }, [socket]);
            
            // Ініціалізація canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = 640;
                    canvas.height = 480;
                    
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    
                    // ВАЖЛИВО: Заповнюємо білим фоном
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const container = canvas.parentElement;
                    const containerWidth = container.getBoundingClientRect().width - 20;
                    if (containerWidth < 640) {
                        canvas.style.width = containerWidth + 'px';
                        canvas.style.height = (containerWidth * 0.75) + 'px';
                    } else {
                        canvas.style.width = '640px';
                        canvas.style.height = '480px';
                    }
                }
            }, []);
            
            const startDrawing = (e) => {
                if (isDrawingLocked || hasFinishedDrawing) return;
                
                setIsDrawing(true);
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = ((e.clientX || e.touches?.[0]?.clientX) - rect.left) * scaleX;
                const y = ((e.clientY || e.touches?.[0]?.clientY) - rect.top) * scaleY;
                
                lastXRef.current = x;
                lastYRef.current = y;
                
                const ctx = canvas.getContext('2d');
                
                // Для гумки використовуємо інший режим
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(x, y, currentSize, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.fillStyle = currentColor;
                    ctx.beginPath();
                    ctx.arc(x, y, currentSize / 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
                
                const strokeData = {
                    x: x / canvas.width,
                    y: y / canvas.height,
                    color: currentColor,
                    size: currentSize,
                    tool: currentTool,
                    type: 'start'
                };
                
                strokeBufferRef.current.push(strokeData);
                setMyDrawingData(prev => [...prev, strokeData]);
            };
            
            const draw = useCallback((e) => {
                if (!isDrawing || isDrawingLocked || hasFinishedDrawing || lastXRef.current === null) return;
                
                e.preventDefault();
                
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = ((e.clientX || e.touches?.[0]?.clientX) - rect.left) * scaleX;
                const y = ((e.clientY || e.touches?.[0]?.clientY) - rect.top) * scaleY;
                
                const ctx = canvas.getContext('2d');
                
                // Важливо: встановлюємо режим для кожного штриха
                if (currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = currentSize * 2;
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = currentColor;
                    ctx.lineWidth = currentSize;
                }
                
                ctx.beginPath();
                ctx.moveTo(lastXRef.current, lastYRef.current);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                lastXRef.current = x;
                lastYRef.current = y;
                
                const strokeData = {
                    x: x / canvas.width,
                    y: y / canvas.height,
                    color: currentColor,
                    size: currentSize,
                    tool: currentTool,
                    type: 'draw'
                };
                
                strokeBufferRef.current.push(strokeData);
                setMyDrawingData(prev => [...prev, strokeData]);
            }, [isDrawing, isDrawingLocked, hasFinishedDrawing, currentColor, currentSize, currentTool]);
            
            const stopDrawing = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    lastXRef.current = null;
                    lastYRef.current = null;
                    const strokeData = {
                        type: 'end'
                    };
                    strokeBufferRef.current.push(strokeData);
                    setMyDrawingData(prev => [...prev, strokeData]);
                }
            };
            
            const clearCanvas = () => {
                if (isDrawingLocked || hasFinishedDrawing) return;
                
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                
                // Скидаємо всі налаштування
                ctx.globalCompositeOperation = 'source-over';
                
                // Заповнюємо БІЛИМ кольором
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 640, 480);
                
                setMyDrawingData([]);
                strokeBufferRef.current = [];
                
                if (socket) {
                    socket.emit('clear_canvas');
                }
            };
            
            const handleFinishDrawing = () => {
                setHasFinishedDrawing(true);
                finishDrawing();
            };
            
            const handleFinishGuessing = () => {
                setHasFinishedGuessing(true);
                finishGuessing();
            };
            
            const myAssignment = roundData?.personalAssignment;
            const otherPlayers = roundData?.players?.filter(p => p.id !== playerId) || [];
            
            return (
                <div className="game-container">
                    <div className="game-header">
                        <div className="round-info">Раунд {roundData?.round} з 4</div>
                    </div>
                    
                    {myAssignment && (
                        <div className="personal-task">
                            <h3>Ваше завдання:</h3>
                            <div className="task-word">{myAssignment.word}</div>
                            <div className="task-info">
                                <span className="task-badge">Карта {myAssignment.letter}</span>
                                <span className="task-badge">Номер {myAssignment.number}</span>
                            </div>
                        </div>
                    )}
                    
                    <div className="drawing-section">
                        <div className="tools-panel">
                            <h3>Інструменти</h3>
                            
                            <div className="tool-group">
                                <label>Тип:</label>
                                <div style={{ display: 'flex', gap: '5px' }}>
                                    <button 
                                        className={`btn btn-secondary ${currentTool === 'pen' ? 'active' : ''}`}
                                        onClick={() => setCurrentTool('pen')}
                                        disabled={isDrawingLocked || hasFinishedDrawing}
                                        style={{ padding: '8px 12px', fontSize: '0.9em' }}
                                    >
                                        ✏️
                                    </button>
                                    <button 
                                        className={`btn btn-secondary ${currentTool === 'eraser' ? 'active' : ''}`}
                                        onClick={() => setCurrentTool('eraser')}
                                        disabled={isDrawingLocked || hasFinishedDrawing}
                                        style={{ padding: '8px 12px', fontSize: '0.9em' }}
                                    >
                                        🧹
                                    </button>
                                </div>
                            </div>
                            
                            <div className="tool-group">
                                <label>Колір:</label>
                                <div className="color-palette">
                                    {colors.map(color => (
                                        <button
                                            key={color}
                                            className={`color-btn ${currentColor === color ? 'active' : ''}`}
                                            style={{ backgroundColor: color }}
                                            onClick={() => setCurrentColor(color)}
                                            disabled={isDrawingLocked || hasFinishedDrawing || currentTool === 'eraser'}
                                        />
                                    ))}
                                </div>
                            </div>
                            
                            <div className="tool-group">
                                <label>Розмір:</label>
                                <div className="size-selector">
                                    {sizes.map(size => (
                                        <button
                                            key={size}
                                            className={`size-btn ${currentSize === size ? 'active' : ''}`}
                                            onClick={() => setCurrentSize(size)}
                                            disabled={isDrawingLocked || hasFinishedDrawing}
                                        >
                                            <div 
                                                className="size-dot" 
                                                style={{ width: size * 0.7, height: size * 0.7 }}
                                            />
                                        </button>
                                    ))}
                                </div>
                            </div>
                            
                            <button 
                                className="btn btn-danger"
                                onClick={clearCanvas}
                                disabled={isDrawingLocked || hasFinishedDrawing}
                                style={{ fontSize: '0.9em', padding: '10px' }}
                            >
                                Очистити
                            </button>
                            
                            {!hasFinishedDrawing && (
                                <button 
                                    className="btn btn-success"
                                    onClick={handleFinishDrawing}
                                    disabled={isDrawingLocked}
                                    style={{ fontSize: '0.9em', padding: '10px' }}
                                >
                                    Готово
                                </button>
                            )}
                        </div>
                        
                        <div className={`canvas-container ${isDrawingLocked ? 'locked' : ''}`}>
                            {isDrawingLocked && (
                                <div className="canvas-lock-overlay">
                                    <div className="lock-message">
                                        Малюнок заблоковано
                                    </div>
                                </div>
                            )}
                            <canvas
                                ref={canvasRef}
                                onMouseDown={startDrawing}
                                onMouseMove={draw}
                                onMouseUp={stopDrawing}
                                onMouseLeave={stopDrawing}
                                onTouchStart={startDrawing}
                                onTouchMove={draw}
                                onTouchEnd={stopDrawing}
                                style={{ 
                                    cursor: isDrawingLocked ? 'not-allowed' : currentTool === 'eraser' ? 'grab' : 'crosshair',
                                    touchAction: 'none'
                                }}
                            />
                        </div>
                    </div>
                    
                    <h3 style={{ marginTop: '30px', color: '#667eea' }}>Відгадайте малюнки інших гравців:</h3>
                    <div className="other-drawings">
                        {otherPlayers.map(player => (
                            <OtherPlayerDrawing
                                key={player.id}
                                player={player}
                                drawing={drawings[player.id] || []}
                                guess={myGuesses[player.id]}
                                usedNumbers={usedNumbers}
                                makeGuess={makeGuess}
                                myNumber={myAssignment?.number}
                                isFinished={finishedDrawingPlayers.has(player.id)}
                            />
                        ))}
                    </div>
                    
                    <div className="word-grid">
                        {['A', 'B', 'C'].map(letter => (
                            <div key={letter} className="word-card">
                                <h3>Карта {letter}</h3>
                                <div className="word-list">
                                    {roundData?.wordSet?.[letter]?.map((word, index) => (
                                        <div 
                                            key={index}
                                            className={`word-item ${
                                                myAssignment?.letter === letter && myAssignment?.number === index + 1 
                                                    ? 'my-word' 
                                                    : ''
                                            }`}
                                        >
                                            <span className="word-number">{index + 1}</span>
                                            {word}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                    
                    <div className="score-hint">
                        <h4>Як рахуються очки:</h4>
                        <div className="score-hint-content">
                            <div className="score-hint-item">
                                <h5>Очки за відгадування</h5>
                                <p>Чим швидше за інших гравців ви правильно відгадаєте малюнок художника, тим більше очок від нього отримаєте. (4→3→3→2→2→2→1→1)</p>
                            </div>
                            <div className="score-hint-item">
                                <h5>Бонусні очки за швидкість</h5>
                                <p>Чим швидше ви завершите відгадування ВСІХ малюнків інших гравців, тим більший бонус очок отримаєте. (4→3→3→2→2→2→1→1)</p>
                            </div>
                        </div>
                    </div>
                    
                    {!hasFinishedGuessing && otherPlayers.length > 0 && (
                        <button 
                            className="btn btn-primary"
                            onClick={handleFinishGuessing}
                            style={{ margin: '20px auto', display: 'block', maxWidth: '300px' }}
                        >
                            Завершив відгадування
                        </button>
                    )}
                </div>
            );
        }
        
        // Компонент для відображення малюнків інших гравців
        function OtherPlayerDrawing({ player, drawing, guess, usedNumbers, makeGuess, myNumber, isFinished }) {
            const canvasRef = useRef(null);
            const [canvasSize] = useState({ width: 240, height: 180 });
            
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                canvas.width = canvasSize.width;
                canvas.height = canvasSize.height;
                
                // ВАЖЛИВО: Білий фон
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                let isDrawingPath = false;
                let lastX = null;
                let lastY = null;
                
                drawing.forEach(stroke => {
                    if (stroke.type === 'start') {
                        const x = stroke.x * canvas.width;
                        const y = stroke.y * canvas.height;
                        
                        if (stroke.tool === 'eraser') {
                            ctx.globalCompositeOperation = 'destination-out';
                            ctx.beginPath();
                            ctx.arc(x, y, stroke.size * (canvasSize.width / 640), 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.globalCompositeOperation = 'source-over';
                        } else {
                            ctx.globalCompositeOperation = 'source-over';
                            ctx.fillStyle = stroke.color;
                            ctx.beginPath();
                            ctx.arc(x, y, (stroke.size * (canvasSize.width / 640)) / 2, 0, 2 * Math.PI);
                            ctx.fill();
                        }
                        
                        lastX = x;
                        lastY = y;
                        isDrawingPath = true;
                    } else if (stroke.type === 'draw' && isDrawingPath && lastX !== null) {
                        const x = stroke.x * canvas.width;
                        const y = stroke.y * canvas.height;
                        
                        if (stroke.tool === 'eraser') {
                            ctx.globalCompositeOperation = 'destination-out';
                            ctx.lineWidth = stroke.size * 2 * (canvasSize.width / 640);
                        } else {
                            ctx.globalCompositeOperation = 'source-over';
                            ctx.strokeStyle = stroke.color;
                            ctx.lineWidth = stroke.size * (canvasSize.width / 640);
                        }
                        
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                        
                        lastX = x;
                        lastY = y;
                    } else if (stroke.type === 'end') {
                        isDrawingPath = false;
                        lastX = null;
                        lastY = null;
                        ctx.globalCompositeOperation = 'source-over';
                    }
                });
            }, [drawing, canvasSize]);
            
            return (
                <div 
                    className={`drawing-card ${guess ? 'guessed' : ''}`}
                    style={isFinished ? {
                        border: '3px solid #FFD700',
                        boxShadow: '0 0 15px rgba(255, 215, 0, 0.5)',
                        backgroundColor: '#FFFACD'
                    } : {}}
                >
                    <div className="drawing-player-name">
                        {player.name}
                        {isFinished && <span style={{ color: '#FFA500', marginLeft: '10px' }}>✅ Готово!</span>}
                    </div>
                    <canvas 
                        ref={canvasRef} 
                        style={{ 
                            width: '100%', 
                            maxWidth: '240px',
                            height: '180px',
                            borderRadius: '10px',
                            background: 'white',
                            border: '1px solid #e0e0e0'
                        }} 
                    />
                    
                    <div className="guess-controls">
                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => {
                            const isMyNumber = num === myNumber;
                            const isUsed = usedNumbers.has(num) && guess !== num;
                            const isSelected = guess === num;
                            
                            return (
                                <button
                                    key={num}
                                    className={`guess-btn ${isSelected ? 'selected' : ''} ${isUsed ? 'used' : ''}`}
                                    onClick={() => makeGuess(player.id, num)}
                                    disabled={isMyNumber || isUsed || guess !== undefined}
                                >
                                    {num}
                                </button>
                            );
                        })}
                    </div>
                </div>
            );
        }
        
        // Рендер додатку з новим API React 18
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>
</html>